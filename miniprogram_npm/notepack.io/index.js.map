{"version":3,"sources":["index.js","encode.js","decode.js","DecodeKeyCache.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["exports.encode = require('./encode');\nexports.decode = require('./decode');\n","\n\nconst MICRO_OPT_LEN = 32;\n\n// Faster for short strings than buffer.write\nfunction utf8Write(arr, offset, str) {\n  let c = 0;\n  for (let i = 0, l = str.length; i < l; i++) {\n    c = str.charCodeAt(i);\n    if (c < 0x80) {\n      arr[offset++] = c;\n    } else if (c < 0x800) {\n      arr[offset++] = 0xc0 | (c >> 6);\n      arr[offset++] = 0x80 | (c & 0x3f);\n    } else if (c < 0xd800 || c >= 0xe000) {\n      arr[offset++] = 0xe0 | (c >> 12);\n      arr[offset++] = 0x80 | (c >> 6) & 0x3f;\n      arr[offset++] = 0x80 | (c & 0x3f);\n    } else {\n      i++;\n      c = 0x10000 + (((c & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));\n      arr[offset++] = 0xf0 | (c >> 18);\n      arr[offset++] = 0x80 | (c >> 12) & 0x3f;\n      arr[offset++] = 0x80 | (c >> 6) & 0x3f;\n      arr[offset++] = 0x80 | (c & 0x3f);\n    }\n  }\n}\n\n// Faster for short strings than Buffer.byteLength\nfunction utf8Length(str) {\n  let c = 0, length = 0;\n  for (let i = 0, l = str.length; i < l; i++) {\n    c = str.charCodeAt(i);\n    if (c < 0x80) {\n      length += 1;\n    } else if (c < 0x800) {\n      length += 2;\n    } else if (c < 0xd800 || c >= 0xe000) {\n      length += 3;\n    } else {\n      i++;\n      length += 4;\n    }\n  }\n  return length;\n}\n\nconst cache = new Map();\nconst cacheMaxSize = process.env.NOTEPACK_ENCODE_CACHE_MAX_SIZE || 1024;\n\n/*jshint latedef: nofunc */\nfunction encodeKey(bytes, defers, key) {\n  if (cache.has(key)) {\n    const buffer = cache.get(key);\n    defers.push({ bin: buffer, length: buffer.length, offset: bytes.length });\n    return buffer.length;\n  }\n  if (cache.size > cacheMaxSize) {\n    return _encode(bytes, defers, key);\n  }\n  const keyBytes = [];\n  const size = _encode(keyBytes, [], key);\n  const keyBuffer = Buffer.allocUnsafe(size);\n  for (let i = 0, l = keyBytes.length; i < l; i++) {\n    keyBuffer[i] = keyBytes[i];\n  }\n  utf8Write(keyBuffer, keyBytes.length, key);\n  defers.push({ bin: keyBuffer, length: size, offset: bytes.length });\n  cache.set(key, keyBuffer);\n  return size;\n}\n\nfunction _encode(bytes, defers, value) {\n  let hi = 0, lo = 0, length = 0, size = 0;\n\n  switch (typeof value) {\n    case 'string':\n      if (value.length > MICRO_OPT_LEN) {\n        length = Buffer.byteLength(value);\n      } else {\n        length = utf8Length(value);\n      }\n\n      if (length < 0x20) { // fixstr\n        bytes.push(length | 0xa0);\n        size = 1;\n      } else if (length < 0x100) { // str 8\n        bytes.push(0xd9, length);\n        size = 2;\n      } else if (length < 0x10000) { // str 16\n        bytes.push(0xda, length >> 8, length);\n        size = 3;\n      } else if (length < 0x100000000) { // str 32\n        bytes.push(0xdb, length >> 24, length >> 16, length >> 8, length);\n        size = 5;\n      } else {\n        throw new Error('String too long');\n      }\n      defers.push({ str: value, length: length, offset: bytes.length });\n      return size + length;\n    case 'number':\n      // TODO: encode to float 32?\n\n      if (Math.floor(value) !== value || !isFinite(value)) { // float 64\n        bytes.push(0xcb);\n        defers.push({ float: value, length: 8, offset: bytes.length });\n        return 9;\n      }\n\n      if (value >= 0) {\n        if (value < 0x80) { // positive fixnum\n          bytes.push(value);\n          return 1;\n        }\n\n        if (value < 0x100) { // uint 8\n          bytes.push(0xcc, value);\n          return 2;\n        }\n\n        if (value < 0x10000) { // uint 16\n          bytes.push(0xcd, value >> 8, value);\n          return 3;\n        }\n\n        if (value < 0x100000000) { // uint 32\n          bytes.push(0xce, value >> 24, value >> 16, value >> 8, value);\n          return 5;\n        }\n        // uint 64\n        hi = (value / Math.pow(2, 32)) >> 0;\n        lo = value >>> 0;\n        bytes.push(0xcf, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);\n        return 9;\n      } else {\n\n        if (value >= -0x20) { // negative fixnum\n          bytes.push(value);\n          return 1;\n        }\n\n        if (value >= -0x80) { // int 8\n          bytes.push(0xd0, value);\n          return 2;\n        }\n\n        if (value >= -0x8000) { // int 16\n          bytes.push(0xd1, value >> 8, value);\n          return 3;\n        }\n\n        if (value >= -0x80000000) { // int 32\n          bytes.push(0xd2, value >> 24, value >> 16, value >> 8, value);\n          return 5;\n        }\n        // int 64\n        hi = Math.floor(value / Math.pow(2, 32));\n        lo = value >>> 0;\n        bytes.push(0xd3, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);\n        return 9;\n      }\n      break;\n    case 'object':\n      // nil\n      if (value === null) {\n        bytes.push(0xc0);\n        return 1;\n      }\n\n      if (Array.isArray(value)) {\n        length = value.length;\n\n        if (length < 0x10) { // fixarray\n          bytes.push(length | 0x90);\n          size = 1;\n        } else if (length < 0x10000) { // array 16\n          bytes.push(0xdc, length >> 8, length);\n          size = 3;\n        } else if (length < 0x100000000) { // array 32\n          bytes.push(0xdd, length >> 24, length >> 16, length >> 8, length);\n          size = 5;\n        } else {\n          throw new Error('Array too large');\n        }\n        for (let i = 0; i < length; i++) {\n          size += _encode(bytes, defers, value[i]);\n        }\n        return size;\n      }\n\n      if (value instanceof Date) { // fixext 8 / Date\n        const time = value.getTime();\n        hi = Math.floor(time / Math.pow(2, 32));\n        lo = time >>> 0;\n        bytes.push(0xd7, 0, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);\n        return 10;\n      }\n\n      if (value instanceof Buffer) {\n        length = value.length;\n\n        if (length < 0x100) { // bin 8\n          bytes.push(0xc4, length);\n          size = 2;\n        } else if (length < 0x10000) { // bin 16\n          bytes.push(0xc5, length >> 8, length);\n          size = 3;\n        } else if (length < 0x100000000) { // bin 32\n          bytes.push(0xc6, length >> 24, length >> 16, length >> 8, length);\n          size = 5;\n        } else {\n          throw new Error('Buffer too large');\n        }\n        defers.push({ bin: value, length: length, offset: bytes.length });\n        return size + length;\n      }\n\n      if (value instanceof ArrayBuffer || ArrayBuffer.isView(value)) {\n        const arraybuffer = value.buffer || value;\n        length = arraybuffer.byteLength;\n\n        // ext 8\n        if (length < 0x100) {\n          bytes.push(0xc7, length, 0);\n          size = 3;\n        } else if (length < 0x10000) { // ext 16\n          bytes.push(0xc8, length >> 8, length, 0);\n          size = 4;\n        } else if (length < 0x100000000) { // ext 32\n          bytes.push(0xc9, length >> 24, length >> 16, length >> 8, length, 0);\n          size = 6;\n        } else {\n          throw new Error('ArrayBuffer too large');\n        }\n        defers.push({ arraybuffer: arraybuffer, length: length, offset: bytes.length });\n        return size + length;\n      }\n\n      if (typeof value.toJSON === 'function') {\n        return _encode(bytes, defers, value.toJSON());\n      }\n\n      const keys = [], allKeys = Object.keys(value);\n      let key = '';\n\n      for (let i = 0, l = allKeys.length; i < l; i++) {\n        key = allKeys[i];\n        if (typeof value[key] !== 'function') {\n          keys.push(key);\n        }\n      }\n      length = keys.length;\n\n      if (length < 0x10) { // fixmap\n        bytes.push(length | 0x80);\n        size = 1;\n      } else if (length < 0x10000) { // map 16\n        bytes.push(0xde, length >> 8, length);\n        size = 3;\n      } else if (length < 0x100000000) { // map 32\n        bytes.push(0xdf, length >> 24, length >> 16, length >> 8, length);\n        size = 5;\n      } else {\n        throw new Error('Object too large');\n      }\n\n      for (let i = 0; i < length; i++) {\n        key = keys[i];\n        size += encodeKey(bytes, defers, key);\n        size += _encode(bytes, defers, value[key]);\n      }\n      return size;\n    case 'boolean': // false/true\n      bytes.push(value ? 0xc3 : 0xc2);\n      return 1;\n    case 'undefined': // fixext 1 / undefined\n      bytes.push(0xd4, 0, 0);\n      return 3;\n    default:\n      throw new Error('Could not encode');\n  }\n}\n\nfunction encode(value) {\n  const bytes = [], defers = [], size = _encode(bytes, defers, value);\n  const buf = Buffer.allocUnsafe(size);\n\n  let deferIndex = 0, deferWritten = 0, nextOffset = -1;\n  if (defers.length > 0) {\n    nextOffset = defers[0].offset;\n  }\n\n  let defer, deferLength = 0, offset = 0;\n  for (let i = 0, l = bytes.length; i < l; i++) {\n    buf[deferWritten + i] = bytes[i];\n    while (i + 1 === nextOffset) {\n      defer = defers[deferIndex];\n      deferLength = defer.length;\n      offset = deferWritten + nextOffset;\n      if (defer.bin) {\n        if (deferLength > MICRO_OPT_LEN) {\n          defer.bin.copy(buf, offset, 0, deferLength);\n        } else {\n          const bin = defer.bin;\n          for (let j = 0; j < deferLength; j++) {\n            buf[offset + j] = bin[j];\n          }\n        }\n      } else if (defer.str) {\n        if (deferLength > MICRO_OPT_LEN) {\n          buf.write(defer.str, offset, deferLength, 'utf8');\n        } else {\n          utf8Write(buf, offset, defer.str);\n        }\n      } else if (defer.float !== undefined) {\n        buf.writeDoubleBE(defer.float, offset);\n      } else if (defer.arraybuffer) {\n        const arr = new Uint8Array(defer.arraybuffer);\n        for (let k = 0; k < deferLength; k++) {\n          buf[offset + k] = arr[k];\n        }\n      }\n      deferIndex++;\n      deferWritten += deferLength;\n      if (defers[deferIndex]) {\n        nextOffset = defers[deferIndex].offset;\n      } else {\n        break;\n      }\n    }\n  }\n  return buf;\n}\n\nmodule.exports = encode;\n","\n\nconst DecodeKeyCache = require('./DecodeKeyCache');\nconst cache = new DecodeKeyCache();\n\nfunction Decoder(buffer) {\n  this.offset = 0;\n  this.buffer = buffer;\n  this.useKeyCache = false;\n}\n\nDecoder.prototype.array = function (length) {\n  const value = new Array(length);\n  for (let i = 0; i < length; i++) {\n    value[i] = this.parse();\n  }\n  return value;\n};\n\nDecoder.prototype.map = function (length) {\n  let key = '', value = {};\n  for (let i = 0; i < length; i++) {\n    this.useKeyCache = true;\n    key = this.parse(true);\n    this.useKeyCache = false;\n    value[key] = this.parse();\n  }\n  return value;\n};\n\nDecoder.prototype.str = function (length) {\n  if (this.useKeyCache) {\n    const valueFromCache = cache.get(this.buffer, this.offset, length);\n    if (valueFromCache) {\n      this.offset += length;\n      return valueFromCache;\n    }\n  }\n  const value = this.buffer.toString('utf8', this.offset, this.offset + length);\n  if (this.useKeyCache) {\n    cache.set(this.buffer, this.offset, length, value);\n  }\n  this.offset += length;\n  return value;\n};\n\nDecoder.prototype.bin = function (length) {\n  const value = this.buffer.slice(this.offset, this.offset + length);\n  this.offset += length;\n  return value;\n};\n\nDecoder.prototype.arraybuffer = function (length) {\n  const buffer = new ArrayBuffer(length);\n  const view = new Uint8Array(buffer);\n  for (let j = 0; j < length; j++) {\n    view[j] = this.buffer[this.offset + j];\n  }\n  this.offset += length;\n  return buffer;\n};\n\nDecoder.prototype.parse = function () {\n  const prefix = this.buffer[this.offset++];\n  let value, length = 0, type = 0, hi = 0, lo = 0;\n\n  if (prefix < 0xc0) {\n    // positive fixint\n    if (prefix < 0x80) {\n      return prefix;\n    }\n    // fixmap\n    if (prefix < 0x90) {\n      return this.map(prefix & 0x0f);\n    }\n    // fixarray\n    if (prefix < 0xa0) {\n      return this.array(prefix & 0x0f);\n    }\n    // fixstr\n    return this.str(prefix & 0x1f);\n  }\n\n  // negative fixint\n  if (prefix > 0xdf) {\n    return (0xff - prefix + 1) * -1;\n  }\n\n  switch (prefix) {\n    // nil\n    case 0xc0:\n      return null;\n    // false\n    case 0xc2:\n      return false;\n    // true\n    case 0xc3:\n      return true;\n\n    // bin\n    case 0xc4:\n      length = this.buffer.readUInt8(this.offset);\n      this.offset += 1;\n      return this.bin(length);\n    case 0xc5:\n      length = this.buffer.readUInt16BE(this.offset);\n      this.offset += 2;\n      return this.bin(length);\n    case 0xc6:\n      length = this.buffer.readUInt32BE(this.offset);\n      this.offset += 4;\n      return this.bin(length);\n\n    // ext\n    case 0xc7:\n      length = this.buffer.readUInt8(this.offset);\n      type = this.buffer.readInt8(this.offset + 1);\n      this.offset += 2;\n      if (type === 0) { // ArrayBuffer\n        return this.arraybuffer(length);\n      }\n      return [type, this.bin(length)];\n    case 0xc8:\n      length = this.buffer.readUInt16BE(this.offset);\n      type = this.buffer.readInt8(this.offset + 2);\n      this.offset += 3;\n      if (type === 0) { // ArrayBuffer\n        return this.arraybuffer(length);\n      }\n      return [type, this.bin(length)];\n    case 0xc9:\n      length = this.buffer.readUInt32BE(this.offset);\n      type = this.buffer.readInt8(this.offset + 4);\n      this.offset += 5;\n      if (type === 0) { // ArrayBuffer\n        return this.arraybuffer(length);\n      }\n      return [type, this.bin(length)];\n\n    // float\n    case 0xca:\n      value = this.buffer.readFloatBE(this.offset);\n      this.offset += 4;\n      return value;\n    case 0xcb:\n      value = this.buffer.readDoubleBE(this.offset);\n      this.offset += 8;\n      return value;\n\n    // uint\n    case 0xcc:\n      value = this.buffer.readUInt8(this.offset);\n      this.offset += 1;\n      return value;\n    case 0xcd:\n      value = this.buffer.readUInt16BE(this.offset);\n      this.offset += 2;\n      return value;\n    case 0xce:\n      value = this.buffer.readUInt32BE(this.offset);\n      this.offset += 4;\n      return value;\n    case 0xcf:\n      hi = this.buffer.readUInt32BE(this.offset) * Math.pow(2, 32);\n      lo = this.buffer.readUInt32BE(this.offset + 4);\n      this.offset += 8;\n      return hi + lo;\n\n    // int\n    case 0xd0:\n      value = this.buffer.readInt8(this.offset);\n      this.offset += 1;\n      return value;\n    case 0xd1:\n      value = this.buffer.readInt16BE(this.offset);\n      this.offset += 2;\n      return value;\n    case 0xd2:\n      value = this.buffer.readInt32BE(this.offset);\n      this.offset += 4;\n      return value;\n    case 0xd3:\n      hi = this.buffer.readInt32BE(this.offset) * Math.pow(2, 32);\n      lo = this.buffer.readUInt32BE(this.offset + 4);\n      this.offset += 8;\n      return hi + lo;\n\n    // fixext\n    case 0xd4:\n      type = this.buffer.readInt8(this.offset);\n      this.offset += 1;\n      if (type === 0x00) {\n        this.offset += 1;\n        return void 0;\n      }\n      return [type, this.bin(1)];\n    case 0xd5:\n      type = this.buffer.readInt8(this.offset);\n      this.offset += 1;\n      return [type, this.bin(2)];\n    case 0xd6:\n      type = this.buffer.readInt8(this.offset);\n      this.offset += 1;\n      return [type, this.bin(4)];\n    case 0xd7:\n      type = this.buffer.readInt8(this.offset);\n      this.offset += 1;\n      if (type === 0x00) {\n        hi = this.buffer.readInt32BE(this.offset) * Math.pow(2, 32);\n        lo = this.buffer.readUInt32BE(this.offset + 4);\n        this.offset += 8;\n        return new Date(hi + lo);\n      }\n      return [type, this.bin(8)];\n    case 0xd8:\n      type = this.buffer.readInt8(this.offset);\n      this.offset += 1;\n      return [type, this.bin(16)];\n\n    // str\n    case 0xd9:\n      length = this.buffer.readUInt8(this.offset);\n      this.offset += 1;\n      return this.str(length);\n    case 0xda:\n      length = this.buffer.readUInt16BE(this.offset);\n      this.offset += 2;\n      return this.str(length);\n    case 0xdb:\n      length = this.buffer.readUInt32BE(this.offset);\n      this.offset += 4;\n      return this.str(length);\n\n    // array\n    case 0xdc:\n      length = this.buffer.readUInt16BE(this.offset);\n      this.offset += 2;\n      return this.array(length);\n    case 0xdd:\n      length = this.buffer.readUInt32BE(this.offset);\n      this.offset += 4;\n      return this.array(length);\n\n    // map\n    case 0xde:\n      length = this.buffer.readUInt16BE(this.offset);\n      this.offset += 2;\n      return this.map(length);\n    case 0xdf:\n      length = this.buffer.readUInt32BE(this.offset);\n      this.offset += 4;\n      return this.map(length);\n  }\n\n  throw new Error('Could not parse');\n};\n\nfunction decode(buffer) {\n  const decoder = new Decoder(buffer);\n  const value = decoder.parse();\n  if (decoder.offset !== buffer.length) {\n    throw new Error((buffer.length - decoder.offset) + ' trailing bytes');\n  }\n  return value;\n}\n\nmodule.exports = decode;\n","const DEFAULT_MAX_SIZE = process.env.NOTEPACK_DECODE_KEY_CACHE_MAX_SIZE || 1024;\nconst DEFAULT_MAX_LENGTH = process.env.NOTEPACK_DECODE_KEY_CACHE_MAX_LENGTH || 16;\n\n/**\n * Store the buffer-to-string values in a tree\n */\nclass DecodeKeyCache {\n  constructor({ maxSize = DEFAULT_MAX_SIZE, maxLength = DEFAULT_MAX_LENGTH } = {}) {\n    this.size = 0;\n    this.maxSize = maxSize;\n    this.maxLength = maxLength;\n    this.cache = new Map();\n    for (let i = 1; i <= this.maxLength; i++) {\n      this.cache.set(i, new Map());\n    }\n  }\n\n  get(buffer, offset, length) {\n    if (length > this.maxLength) { return false; }\n    let node = this.cache.get(length);\n    for (let i = 0; i < length; i++) {\n      const byte = buffer[offset + i];\n      if (node.has(byte)) {\n        node = node.get(byte);\n      } else {\n        return false;\n      }\n    }\n    return node;\n  }\n\n  set(buffer, offset, length, value) {\n    if (length > this.maxLength || this.size >= this.maxSize) { return; }\n    this.size++;\n    let node = this.cache.get(length);\n    for (let i = 0; i < length; i++) {\n      const byte = buffer[offset + i];\n      if (i === length - 1) {\n        node.set(byte, value);\n      } else if (node.has(byte)) {\n        node = node.get(byte);\n      } else {\n        const newNode = new Map();\n        node.set(byte, newNode);\n        node = newNode;\n      }\n    }\n  }\n}\n\nmodule.exports = DecodeKeyCache;\n"]}